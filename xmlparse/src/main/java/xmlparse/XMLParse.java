package xmlparse;

import java.io.File;
import java.io.IOException;
import java.io.StringWriter;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.TransformerFactoryConfigurationError;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

public class XMLParse {

	public static void main(String[] args) throws ParserConfigurationException, SAXException, IOException {
		
		//Get the file from the resources directory
		File file = new File("src/main/resources/Report.xml");
		
		//Setup DOM document that can be read from
		DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
		DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
		Document document = documentBuilder.parse(file);
		document.getDocumentElement().normalize();
		
		//Get all the nodes found in the document using wildcard search
		//A node is just a java object for a XML element/tag
	    NodeList nodes=document.getElementsByTagName("*");
	    for(int i=0;i<nodes.getLength();i++) {
	    	//Cast to an element
	    	//Has some extra functionality that a tag does not have
	    	Element element = (Element)nodes.item(i);
	    	System.out.println("Has Parent: "+nodeHasParent(element));
	    	System.out.println("Node Name: "+element.getTagName());
	    	//Check if the node is a pure child, i.e. actually has data and does not hold other tags
	    	if(isPureChild(element)) {
	    		//Print info
	    		System.out.println("Element Node Detected!");
	    		System.out.println("XML Tag Name: "+element.getTagName());
				System.out.println("Formatted Tag Hierarchy: ");
				System.out.println(getNodeTagFormattedXMLHierarchy(element));
				System.out.println("Element Data: "+element.getTextContent());
	    	}
	    	System.out.println();
	    }
	}
	/**
	 * Generates the entire XML hierarchy for a node, excluding all other childs and data.
	 * This is generated by navigating up through the hierarchy, getting the parent tag, formatting it, and adding it to the existing string. 
	 * @param node the node to get the formatted xml for
	 * @return
	 */
	public static String getNodeTagFormattedXMLHierarchy(Node node) {
		// TODO Remove this when fully tested better method
		//Alternative method for getting formatted XML
		/*String formattedXML;
		String formattedXMLStartTag = formatStartTag(node.getNodeName());
		String formattedXMLEndTag = formatEndTag(node.getNodeName());
		formattedXML = formattedXMLStartTag+System.lineSeparator()+formattedXMLEndTag;*/
		/*Node parentNode = node.getParentNode();
		while(nodeHasParent(parentNode)) {
			String startTag = formatStartTag(parentNode.getNodeName());
			String endTag = formatEndTag(parentNode.getNodeName());
			formattedXML = startTag+System.lineSeparator()+formattedXML+System.lineSeparator()+endTag;
			parentNode = parentNode.getParentNode();
		}*/
		
		String formattedXML="";
		//Get the number of parents a iterate through them
		int numParents = getNumParentsForNode(node);
		for(int i=0;i<numParents;i++) {
			//Get start and end tag
			String startTag = formatStartTag(node.getNodeName());
			String endTag = formatEndTag(node.getNodeName());
			//Format the innermost tag differently
			if(i==0) {
				formattedXML = formatXmlWithoutInner(numParents-(i+1), startTag, endTag);
			}
			else {
				formattedXML = formatXmlWithInner(numParents-(i+1), startTag, endTag, formattedXML);
			}
			//Get the current node to the parent node
			node = node.getParentNode();
		}
		return formattedXML;
	}
	
	/**
	 * Formats the XML as a tag with inner tags, i.e. a tag that contains child elements
	 * This is needed since the formatting is different from one without child elements, there is an extra line separator. 
	 * @param numTabs
	 * @param startTag
	 * @param endTag
	 * @param innerTag
	 * @return
	 */
	public static String formatXmlWithInner(int numTabs, String startTag, String endTag, String innerTag) {
		String formattedXML = generateTabs(numTabs)+startTag+System.lineSeparator()+innerTag+System.lineSeparator()+generateTabs(numTabs)+endTag;
		return formattedXML;
	}
	
	/**
	 * Formats XML as the innermost tag. i.e. the bottom of the hierarchy.
	 * This tag does not contain any child elements
	 * This is needed since the formatting is slightly different, there is one less line separator. 
	 * @param numTabs
	 * @param startTag
	 * @param endTag
	 * @return
	 */
	public static String formatXmlWithoutInner(int numTabs, String startTag, String endTag) {
		String formattedXML = generateTabs(numTabs)+startTag+System.lineSeparator()+generateTabs(numTabs)+endTag;
		return formattedXML;
	}
	
	/**
	 * Generator "tabs" to format the XML nicely
	 * Used spaces instead of tabs since tabs appear too big
	 * @param numTabs
	 * @return
	 */
	public static String generateTabs(int numTabs) {
		String tabs="";
		for (int i=0;i<numTabs;i++) {
			tabs+="   ";
		}
		return tabs;
	}
	
	/**
	 * Gets the number of parents for a given node
	 * Navigates up through the hiearchy and counts each parent node
	 * @param node
	 * @return
	 */
	public static int getNumParentsForNode(Node node) {
		int numParents = 0;
		Node parentNode = node;
		while(nodeHasParent(parentNode)) {
			numParents++;
			parentNode = parentNode.getParentNode();
		}
		return numParents;
	}
	
	
	/**
	 * Manually format a given string as an xml start tag.
	 * e.x. "person" will be formatted as &#60;person&#62
	 * @param string
	 * @return
	 */
	public static String formatStartTag(String string) {
		String startTag="<"+string+">";
		return startTag;
	}
	
	/**
	 * Manually format a given string as an xml end tag.
	 * e.x. "address" will be formatted as 	&#60;/address&#62;
	 * @param string
	 * @return
	 */
	public static String formatEndTag(String string) {
		String endTag = "</"+string+">";
		return endTag;
	}
	
	/**
	 * Returns true if a node has a parent, i.e. is not the root node
	 * @param node
	 * @return
	 */
	public static boolean nodeHasParent(Node node) {
		//the document node should be the root node, double check this however with fuller xml
		if(node.getParentNode().getNodeType()==Node.DOCUMENT_NODE) {
			return false;
		}
		else {
			return true;
		}
	}
	
	/**
	 * Determine if a node has child elements, i.e. is the bottom of the hierarchy.
	 * @param node
	 * @return
	 */
	public static boolean isPureChild(Node node) {
		//Use less than 2, since the data in a element counts as a child node
		if(node.getChildNodes().getLength()<2) {
			return true;
		}
		else {
			return false;
		}
	}
	
	//Alternative method for converting node to xml string, using xml string writter
	//Ended up not using, but leaving here for future reference
	public static String nodeToString(Node node) {
		Transformer transformer;
		try {
			transformer = TransformerFactory.newInstance().newTransformer();
			transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
			StringWriter writer = new StringWriter();
	        transformer.transform(new DOMSource(node), new StreamResult(writer));
			return writer.toString();
			
		} catch (TransformerConfigurationException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (TransformerFactoryConfigurationError e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (TransformerException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return "";
	}
	
	public static void  iterateNodes(Node parent) {
		NodeList childNodes = parent.getChildNodes();
		for(int i=0;i<childNodes.getLength();i++) {
			Node node = childNodes.item(i);
			if(node.getNodeType()==Node.ELEMENT_NODE) {
				Element element = (Element) node;
				System.out.println("Element Node Detected!");
				System.out.println("Element Tag: "+element.getTagName());
				System.out.println("Element Data: "+element.getTextContent());
				System.out.println();
				iterateNodes(element);
			}
		}
	}
}
